#!/usr/bin/python
# vim: set fileencoding=utf-8:

"""A machination module to calculate the difference between profile and status.

Machination (and its workers) will call this library to ask for a 'worklist'
based on differences between the 'local' status.xml and the downloaded profile.

"""

import pprint
from lxml import etree


class XMLCompare(object):

    def __init__(self, leftxml, rightxml):
        self.leftroot = leftxml.getroot()
        self.rightroot = rightxml.getroot()
        self.leftset = set()
        self.rightset = set()
        self.bystate = {'left':{}, 'right':{}, 'same':{}, 'diff':{}}
        self.byxpath = {}

    def compare(self):
        """Compare the xpath sets generated by xml_to_xpath and return worklist"""

        self.xml_to_xpath()

        for xpath in self.leftset.difference(self.rightset):
            self.bystate['left'][xpath] = 1
            self.byxpath[xpath] = 'left'
        for xpath in self.rightset.difference(self.leftset):
            self.bystate['right'][xpath] = 1
            self.byxpath[xpath] = 'right'

        for xpath in self.leftset.intersection(self.rightset):
            #etree needs relative paths here against the root
            l = self.leftroot.xpath(xpath.lstrip('/'))
            r = self.rightroot.xpath(xpath.lstrip('/'))

            #l[0] or r[0] can be element objects, or attr strings
            #Try to get the tag - if it fails, it wasn't an element object!
            lval = ""
            rval = ""

            try:
                lval = l[0].tag
                rval = r[0].tag
            except AttributeError:
                lval = l[0]
                rval = r[0]

            if lval == rval:
                self.bystate['same'][xpath] = 1
                self.byxpath[xpath] = 'same'
            else:
                ### What about if the attrib of an elt is diff?
                ### Pass this back up to parent xpath somehow?
                self.bystate['diff'][xpath] = 1
                self.byxpath[xpath] = 'diff'

    def xml_to_xpath(self):

        for elt in self.leftroot:
            self.make_xpath(self.leftset, elt)

        for elt in self.rightroot:
            self.make_xpath(self.rightset, elt)

        return self.leftset, self.rightset

    def make_xpath(self, xpathset, elt, current="/"):
        """Recursively construct xpaths for each element and its attributes, and children."""
        id = ""
        if elt.attrib.get("id"):
            id = "[@id='%s']" % (elt.attrib.get("id"))

        xpath = "%s%s%s" % (current, elt.tag, id)
        xpathset.add(xpath)

        for attr in elt.attrib:
            attr_path = "%s/@%s" % (xpath, attr)
            xpathset.add(attr_path)

        #Recurse
        current = xpath + "/"
        for childelt in elt:
            self.make_xpath(xpathset, childelt, current)


if __name__ == "__main__":

    pp = pprint.PrettyPrinter()

    inputfile = "input.xml"
    statusfile = "status.xml"

    with open(inputfile) as inp:
        leftxml = etree.parse(inp)
    with open(statusfile) as st:
        rightxml = etree.parse(st)

    xmlcmp = XMLCompare(leftxml, rightxml)

    xmlcmp.compare()

#    pp.pprint(xmlcmp.bystate)
    print
    pp.pprint(xmlcmp.byxpath)
